## ABI encoding是什么
Solidity自从0.4.24之后添加了许多ABI编码方法，文档中是这样描述的：

- `abi.decode(bytes memory encodedData, (...)) returns (...)`: ABI解码给定的数据，类型作为第二个参数在括号中给出。
  
  例如: `(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))`
- `abi.encode(...) returns (bytes memory)`: ABI编码给定的参数
- `abi.encodePacked(...) returns (bytes memory)`: 对给定参数执行压缩编码。请注意，这种编码可能是不明确的
- `abi.encodeWithSelector(bytes4 selector, ...) returns (bytes memory)`: 对给定参数从第二个开始进行ABI编码，并在给定的4字节选择器之前添加
- `abi.encodeWithSignature(string memory signature, ...) returns (bytes memory)`: 
  
  等价于 `abi.encodeWithSelector(bytes4(keccak256(bytes(signature)), ...)`

这几个方法在动态调用函数时是十分有用的。

### `abi.encode`
例子一: 如果只编码单个字符串
> `abi.encode("AAAA");`

会得到下面的输出

> 0x0000000000000000000000000000000000000000000000000000000000000020
> 0x0000000000000000000000000000000000000000000000000000000000000004
> 0x4141414100000000000000000000000000000000000000000000000000000000

- 第一行是 0x20 填充到32字节 表示第一个参数的起始偏移量
- 第二行是 0x40 填充到32字节 表示参数字符串的长度
- 第三行是 "AAAA" UTF-8编码 同样填充到32字节

例子二: 编码2个字符串
> `abi.encode("AAAA", "BBBB");`

得到下面的输出结果

> 0x0000000000000000000000000000000000000000000000000000000000000040
> 0x0000000000000000000000000000000000000000000000000000000000000080
> 0x0000000000000000000000000000000000000000000000000000000000000004
> 0x4141414100000000000000000000000000000000000000000000000000000000
> 0x0000000000000000000000000000000000000000000000000000000000000004
> 0x4242424200000000000000000000000000000000000000000000000000000000

- 第一行是0x40 表示第一个参数的起始偏移值
- 第二行是0x80 表示第二个参数的起始偏移值
- 第三行是0x04 表示第一个字符串的长度
- 第四行是 "AAAA"
- 第五行是0x04 表示第二个字符串的长度
- 第六行是 "BBBB"

你甚至可以编码数组进去

```
uint8[3] memory arr = [0x1, 0x2, 0x42];
abi.encode(arr, "AAAA", "BBBB");
```

会得到下面的结果

> 0x0000000000000000000000000000000000000000000000000000000000000001
> 0x0000000000000000000000000000000000000000000000000000000000000002
> 0x0000000000000000000000000000000000000000000000000000000000000042
> 0x00000000000000000000000000000000000000000000000000000000000000a0
> 0x00000000000000000000000000000000000000000000000000000000000000e0
> 0x0000000000000000000000000000000000000000000000000000000000000004
> 0x4141414100000000000000000000000000000000000000000000000000000000
> 0x0000000000000000000000000000000000000000000000000000000000000004
> 0x4242424200000000000000000000000000000000000000000000000000000000

- 因为数组是固定长度的，所以数组的三个元素会直接在前三行输出
- 第四行是"AAAA"的偏移量
- 第五行是"BBBB"的偏移量
- 第六行是"AAAA"的字符串长度
- 第七行是字符串"AAAA"
- 第八行是"BBBB"的字符串长度
- 第九行是字符串"BBBB"

### `abi.encodePacked`
encode packed比encode更简单，动态类型是就地编码的，没有长度。如果静态类型少于32个字节，也不会填充

例如，打包编码一个单独的string

`abi.encodePacked("AAAA");`

只是输出了`0x41414141`，这与将其转换为字节的结果完全相同

再用字符串和uint一起打包编码

`abi.encodePacked(uint8(0x42), uint256(0x1337), "AAAA", "BBBB");`

输出如下

> 0x42
> 0x0000000000000000000000000000000000000000000000000000000000001337
> 0x41414141
> 0x42424242

有趣的是数组不一定要打包元素

```
uint8[3] memory arr = [0x1, 0x2, 0x42];
abi.encodePacked(arr, "AAAA", "BBBB");
```

输出结果是这样的

> 0x0000000000000000000000000000000000000000000000000000000000000001
> 0x0000000000000000000000000000000000000000000000000000000000000002
> 0x0000000000000000000000000000000000000000000000000000000000000042
> 0x41414141
> 0x42424242

因此 `uint8` 数组元素仍旧被填充到32个字节

### `keccak256编码行为`
在ABI encoding被引入之前，keccak方法接收多个参数

`keccak256("AAAA", "BBBB", 42);`

它一直在隐式的进行encodePacked，但是现在如果尝试使用keccak，可能会收到编译器警告

> This function only accepts a single "bytes" argument

